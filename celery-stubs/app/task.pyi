from typing import Any, Optional, Tuple, Dict, Mapping, TypeVar, Callable, Generic, ParamSpec

from billiard.einfo import ExceptionInfo
from celery.backends.base import Backend
from celery.canvas import Signature
from celery.result import EagerResult
from kombu import Producer

from celery import Celery, result

# Params and return type of wrapped task function
P = ParamSpec('P')
R = TypeVar('R')


TaskType = type

class Context:
    logfile: Any = ...
    loglevel: Any = ...
    hostname: Any = ...
    id: Any = ...
    args: Any = ...
    kwargs: Any = ...
    retries: int = ...
    eta: Any = ...
    expires: Any = ...
    is_eager: bool = ...
    headers: Any = ...
    delivery_info: Any = ...
    reply_to: Any = ...
    root_id: Any = ...
    parent_id: Any = ...
    correlation_id: Any = ...
    taskset: Any = ...
    group: Any = ...
    chord: Any = ...
    chain: Any = ...
    utc: Any = ...
    called_directly: bool = ...
    callbacks: Any = ...
    errbacks: Any = ...
    timelimit: Any = ...
    origin: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def update(self, *args: Any, **kwargs: Any): ...
    def clear(self): ...
    def get(self, key: Any, default: Optional[Any] = ...): ...
    def as_execution_options(self): ...
    @property
    def children(self): ...

class Task(Generic[P, R]):
    __call__: Callable[P, R]
    delay: Callable[P, result.AsyncResult[R]]

    __trace__: Any = ...
    __v2_compat__: bool = ...
    MaxRetriesExceededError: Any = ...
    OperationalError: Any = ...
    Strategy: str = ...
    Request: str = ...
    name: Any = ...
    typing: Any = ...
    max_retries: int = ...
    default_retry_delay: Any = ...
    rate_limit: Any = ...
    ignore_result: Any = ...
    trail: bool = ...
    send_events: bool = ...
    store_errors_even_if_ignored: Any = ...
    serializer: Any = ...
    time_limit: Any = ...
    soft_time_limit: Any = ...
    autoregister: bool = ...
    track_started: Any = ...
    acks_late: Any = ...
    acks_on_failure_or_timeout: Any = ...
    reject_on_worker_lost: Any = ...
    throws: Any = ...
    expires: Any = ...
    priority: Any = ...
    resultrepr_maxsize: int = ...
    request_stack: Any = ...
    abstract: bool = ...
    __bound__: bool = ...
    from_config: Any = ...
    @classmethod
    def bind(cls, app: Celery) -> Celery: ...
    @classmethod
    def on_bound(cls, app: Celery) -> None: ...
    app: Celery = ...
    @classmethod
    def annotate(cls) -> None: ...
    @classmethod
    def add_around(cls, attr: Any, around: Any) -> None: ...
    def __reduce__(self) -> Any: ...
    def run(self, *args: Any, **kwargs: Any) -> None: ...
    def start_strategy(self, app: Celery, consumer: Any, **kwargs: Any) -> Any: ...
    def apply_async(self, args: Optional[Tuple[Any, ...]] = ..., kwargs: Optional[Dict[str, Any]] = ..., task_id: Optional[str] = ..., producer: Optional[Producer] = ..., link: Optional[Signature] = ..., link_error: Optional[Signature] = ..., shadow: Optional[str] = ..., **options: Any) -> result.AsyncResult[R]: ...
    def shadow_name(self, args: Optional[Tuple[Any, ...]], kwargs: Optional[Dict[str, Any]], options: Dict[str, Any]) -> Optional[str]: ...
    def signature_from_request(self, request: Optional[Any] = ..., args: Optional[Any] = ..., kwargs: Optional[Any] = ..., queue: Optional[Any] = ..., **extra_options: Any) -> Any: ...
    # subtask_from_request() is alias for signature_from_request()
    def subtask_from_request(self, request: Optional[Any] = ..., args: Optional[Any] = ..., kwargs: Optional[Any] = ..., queue: Optional[Any] = ..., **extra_options: Any) -> Any: ...
    def retry(self, args: Optional[Any] = ..., kwargs: Optional[Any] = ..., exc: Optional[Any] = ..., throw: bool = ..., eta: Optional[Any] = ..., countdown: Optional[Any] = ..., max_retries: Optional[Any] = ..., **options: Any) -> Any: ...
    def apply(self, args: Optional[Any] = ..., kwargs: Optional[Any] = ..., link: Optional[Any] = ..., link_error: Optional[Any] = ..., task_id: Optional[Any] = ..., retries: Optional[Any] = ..., throw: Optional[Any] = ..., logfile: Optional[Any] = ..., loglevel: Optional[Any] = ..., headers: Optional[Any] = ..., **options: Any) -> EagerResult[R]: ...
    def AsyncResult(self, task_id: Any, **kwargs: Any) -> result.AsyncResult: ...
    def signature(self, args: Optional[Any] = ..., *starargs: Any, **starkwargs: Any) -> Any: ...
    # subtask() is alias of signature()
    def subtask(self, args: Optional[Any] = ..., *starargs: Any, **starkwargs: Any) -> Any: ...
    def s(self, *args: Any, **kwargs: Any) -> Any: ...
    def si(self, *args: Any, **kwargs: Any) -> Any: ...
    def chunks(self, it: Any, n: Any) -> Any: ...
    def map(self, it: Any) -> Any: ...
    def starmap(self, it: Any) -> Any: ...
    def send_event(self, type_: str, retry: bool = ..., retry_policy: Optional[Mapping] = ..., **fields: Any) -> Any: ...
    def replace(self, sig: Signature) -> Any: ...
    def add_to_chord(self, sig: Any, lazy: bool = ...) -> Any: ...
    def update_state(self, task_id: Optional[Any] = ..., state: Optional[Any] = ..., meta: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def on_success(self, retval: Any, task_id: str, args: Any, kwargs: Any) -> None: ...
    def on_retry(self, exc: Any, task_id: str, args: Tuple[Any, ...], kwargs: Dict[str, Any], einfo: ExceptionInfo) -> None: ...
    def on_failure(self, exc: Any, task_id: str, args: Tuple[Any, ...], kwargs: Dict[str, Any], einfo: ExceptionInfo) -> None: ...
    def after_return(self, status: Any, retval: Any, task_id: str, args: Tuple[Any, ...], kwargs: Dict[str, Any], einfo: ExceptionInfo) -> None: ...
    def add_trail(self, result: Any) -> Any: ...
    def push_request(self, *args: Any, **kwargs: Any) -> None: ...
    def pop_request(self) -> None: ...
    request: Any = ...
    @property
    def backend(self) -> Backend: ...
    @backend.setter
    def backend(self, value: Backend) -> None: ...
    @property
    def __name__(self) -> str: ...

BaseTask = Task
